//
//  AnalysisViewController.swift
//  CRMS
//
//  Created by Hoor Hasan on 22/12/2025.
//

import UIKit
import PDFKit

final class AnalysisViewController: UIViewController {

    // IBOutlets
    @IBOutlet weak var analyticsSegment: UISegmentedControl!

    @IBOutlet weak var requestAnalysis: UIView!
    @IBOutlet weak var timeAnalysis: UIView!
    @IBOutlet weak var escalationAnalysis: UIView!
    @IBOutlet weak var categoryAnalysis: UIView!

    @IBOutlet weak var savePDF: UIImageView!

    private let logo = UIImage(named: "Light mode logo, compressed & cropped")

    // PDF constants
    private let pageBounds = CGRect(x: 0, y: 0, width: 595, height: 842) // A4
    private let leftPadding: CGFloat = 20
    private let startY: CGFloat = 90
    private let contentWidth: CGFloat = 555 // 595 - 40
    private let footerSpace: CGFloat = 40

    override func viewDidLoad() {
        super.viewDidLoad()

        title = "Analytics"

        // show first segment by default
        analyticsSegment.selectedSegmentIndex = 0
        showSelectedAnalysis(animated: false)

        // make PDF icon tappable
        savePDF.isUserInteractionEnabled = true
        let tapGesture = UITapGestureRecognizer(target: self, action: #selector(generatePDF))
        savePDF.addGestureRecognizer(tapGesture)
    }

    // segment change
    @IBAction func segmentChanged(_ sender: UISegmentedControl) {
        showSelectedAnalysis(animated: true)
    }

    // show selected analysis
    private func showSelectedAnalysis(animated: Bool) {

        let views = [requestAnalysis, timeAnalysis, escalationAnalysis, categoryAnalysis]
        let selectedIndex = analyticsSegment.selectedSegmentIndex

        for (index, view) in views.enumerated() {

            let shouldShow = (index == selectedIndex)

            if animated {

                if shouldShow {
                    view?.alpha = 0.0
                    view?.isHidden = false
                    UIView.animate(withDuration: 0.3) {
                        view?.alpha = 1.0
                    }
                } else {
                    UIView.animate(withDuration: 0.3, animations: {
                        view?.alpha = 0.0
                    }, completion: { _ in
                        view?.isHidden = true
                    })
                }

            } else {
                view?.isHidden = !shouldShow
                view?.alpha = shouldShow ? 1.0 : 0.0
            }
        }
    }

    // generate PDF
    @objc private func generatePDF() {

        showConfirmationAlert(title: "Save PDF",
                              message: "Do you want to save the analytics as a PDF?") { [weak self] in
            guard let self = self else { return }

            // make sure layout is updated
            self.view.layoutIfNeeded()

            // force layout + reload nested lists (charts/collection/table)
            let containers = [self.requestAnalysis, self.timeAnalysis, self.escalationAnalysis, self.categoryAnalysis]
            for c in containers {
                c?.setNeedsLayout()
                c?.layoutIfNeeded()
                if let root = c { self.reloadNestedLists(in: root) }
            }

            // small delay to let charts finish drawing
            RunLoop.current.run(until: Date().addingTimeInterval(0.05))

            self.createAndSavePDF()
        }
    }

    private func createAndSavePDF() {

        let fileName = "Performance_Analysis_Report.pdf"

        let fileURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
            .appendingPathComponent(fileName)

        let renderer = UIGraphicsPDFRenderer(bounds: pageBounds)

        do {
            try renderer.writePDF(to: fileURL) { context in

                let analysisViews = [self.requestAnalysis, self.timeAnalysis, self.escalationAnalysis, self.categoryAnalysis]

                for (idx, viewOpt) in analysisViews.enumerated() {
                    guard let container = viewOpt else { continue }

                    // save visibility
                    let wasHidden = container.isHidden
                    let oldAlpha = container.alpha

                    // show for rendering
                    container.isHidden = false
                    container.alpha = 1.0
                    container.layoutIfNeeded()

                    // start first page for this section
                    context.beginPage()
                    self.drawPDFHeader(sectionIndex: idx)
                    self.drawPDFFooter(pageIndexText: "Page 1")

                    // draw content (auto handles scroll & multi-pages)
                    self.drawContainerIncludingScroll(container, pdfContext: context)

                    // restore
                    container.isHidden = wasHidden
                    container.alpha = oldAlpha
                }
            }

            // share (Save to Files to appear in Files app)
            let vc = UIActivityViewController(activityItems: [fileURL], applicationActivities: nil)
            vc.popoverPresentationController?.sourceView = self.view
            present(vc, animated: true)

            print("PDF URL:", fileURL)
            print("PDF Exists:", FileManager.default.fileExists(atPath: fileURL.path))

        } catch {
            showAlert(title: "Error", message: "Failed to generate the PDF.")
        }
    }

    // MARK: - Header / Footer

    private func drawPDFHeader(sectionIndex: Int) {

        // logo
        let logoRect = CGRect(x: 20, y: 20, width: 40, height: 40)
        logo?.draw(in: logoRect)

        // title
        let title = "Performance Analysis Report"
        let attributes: [NSAttributedString.Key: Any] = [
            .font: UIFont.boldSystemFont(ofSize: 18)
        ]
        title.draw(at: CGPoint(x: 70, y: 30), withAttributes: attributes)

        // optional section label
        let sectionTitles = ["Requests", "Time", "Escalations", "Categories"]
        let section = sectionIndex < sectionTitles.count ? sectionTitles[sectionIndex] : "Analytics"
        let secAttr: [NSAttributedString.Key: Any] = [
            .font: UIFont.systemFont(ofSize: 12),
            .foregroundColor: UIColor.gray
        ]
        section.draw(at: CGPoint(x: 70, y: 52), withAttributes: secAttr)

        // divider
        let path = UIBezierPath()
        path.move(to: CGPoint(x: 20, y: 70))
        path.addLine(to: CGPoint(x: 575, y: 70))
        path.lineWidth = 1
        path.stroke()
    }

    private func drawPDFFooter(pageIndexText: String) {

        let formatter = DateFormatter()
        formatter.dateStyle = .medium

        let footerText = "Generated on \(formatter.string(from: Date()))   •   \(pageIndexText)"
        let attributes: [NSAttributedString.Key: Any] = [
            .font: UIFont.systemFont(ofSize: 10),
            .foregroundColor: UIColor.gray
        ]

        footerText.draw(at: CGPoint(x: 20, y: pageBounds.height - 22), withAttributes: attributes)
    }

    // MARK: - Core: draw container + FULL scroll content across pages

    private func drawContainerIncludingScroll(_ containerView: UIView, pdfContext context: UIGraphicsPDFRendererContext) {

        // find first scroll inside container (you said you have only one)
        if let scrollView = findFirstScrollContainer(in: containerView) {
            drawScrollViewFullContent(scrollView, pdfContext: context)
        } else {
            drawNormalView(containerView)
        }
    }

    // draw a normal view (not scrollable) on one page
    private func drawNormalView(_ view: UIView) {

        guard let ctx = UIGraphicsGetCurrentContext() else { return }

        let maxDrawableHeight = pageBounds.height - startY - footerSpace

        // fit height based on autolayout
        let targetSize = CGSize(width: contentWidth, height: UIView.layoutFittingCompressedSize.height)
        let fittedHeight = view.systemLayoutSizeFitting(
            targetSize,
            withHorizontalFittingPriority: .required,
            verticalFittingPriority: .fittingSizeLevel
        ).height

        let scale = min(1.0, maxDrawableHeight / max(fittedHeight, 1))

        ctx.saveGState()
        ctx.translateBy(x: leftPadding, y: startY)
        ctx.scaleBy(x: scale, y: scale)
        view.layer.render(in: ctx)
        ctx.restoreGState()
    }

    // ✅ draw FULL scroll content and split into multiple A4 pages
    private func drawScrollViewFullContent(_ scrollView: UIScrollView, pdfContext context: UIGraphicsPDFRendererContext) {

        guard let ctx = UIGraphicsGetCurrentContext() else { return }

        // make sure contentSize is correct (collection/table/charts)
        reloadNestedLists(in: scrollView)
        scrollView.layoutIfNeeded()

        let originalOffset = scrollView.contentOffset
        let originalFrame = scrollView.frame

        scrollView.contentOffset = .zero
        scrollView.layoutIfNeeded()

        // full content size
        let contentSize = scrollView.contentSize
        let contentHeight = max(contentSize.height, scrollView.bounds.height)

        // how much height we can draw per page
        let drawableHeight = pageBounds.height - startY - footerSpace
        let pageSliceHeight = drawableHeight

        // scale to fit width
        let scale = contentWidth / max(contentSize.width, 1)

        // how many pages needed
        let totalScaledHeight = contentHeight * scale
        let pages = Int(ceil(totalScaledHeight / pageSliceHeight))

        for pageIndex in 0..<pages {

            if pageIndex > 0 {
                context.beginPage()
                drawPDFHeader(sectionIndex: 0) // header again (simple)
                drawPDFFooter(pageIndexText: "Page \(pageIndex + 1)")
            }

            // clip to page area
            ctx.saveGState()
            ctx.translateBy(x: leftPadding, y: startY)

            // define visible slice rect in PDF coordinates
            let clipRect = CGRect(x: 0, y: 0, width: contentWidth, height: drawableHeight)
            ctx.clip(to: clipRect)

            // move content up for each page slice
            // (negative Y to show lower parts)
            let yOffset = CGFloat(pageIndex) * pageSliceHeight
            ctx.translateBy(x: 0, y: -yOffset)

            // scale to fit width
            ctx.scaleBy(x: scale, y: scale)

            // render full scroll content
            // IMPORTANT: expand frame height so layer renders full content
            scrollView.frame = CGRect(x: 0, y: 0, width: scrollView.frame.width, height: contentHeight)
            scrollView.layer.render(in: ctx)

            ctx.restoreGState()
        }

        // restore original state
        scrollView.contentOffset = originalOffset
        scrollView.frame = originalFrame
        scrollView.layoutIfNeeded()
    }

    // find first scroll inside a view
    private func findFirstScrollContainer(in root: UIView) -> UIScrollView? {

        if let scroll = root as? UIScrollView { return scroll }

        for sub in root.subviews {
            if let found = findFirstScrollContainer(in: sub) {
                return found
            }
        }
        return nil
    }

    // reload collection/table inside any view
    private func reloadNestedLists(in root: UIView) {

        if let c = root as? UICollectionView {
            c.reloadData()
            c.layoutIfNeeded()
        }

        if let t = root as? UITableView {
            t.reloadData()
            t.layoutIfNeeded()
        }

        for sub in root.subviews {
            reloadNestedLists(in: sub)
        }
    }

    // MARK: - Alerts

    private func showConfirmationAlert(title: String, message: String, confirmHandler: @escaping () -> Void) {

        let alert = UIAlertController(title: title, message: message, preferredStyle: .alert)

        alert.addAction(UIAlertAction(title: "Yes", style: .default, handler: { _ in
            confirmHandler()
        }))

        alert.addAction(UIAlertAction(title: "No", style: .cancel))

        present(alert, animated: true)
    }

    private func showAlert(title: String, message: String) {

        let alert = UIAlertController(title: title, message: message, preferredStyle: .alert)
        alert.addAction(UIAlertAction(title: "OK", style: .default))

        present(alert, animated: true)
    }
}
