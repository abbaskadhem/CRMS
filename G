//
//  AnalysisViewController.swift
//  CRMS
//
//  Created by Hoor Hasan on 22/12/2025.
//

import UIKit
import PDFKit

final class AnalysisViewController: UIViewController {

    // MARK: - IBOutlets
    @IBOutlet weak var analyticsSegment: UISegmentedControl!

    @IBOutlet weak var requestAnalysis: UIView!
    @IBOutlet weak var timeAnalysis: UIView!
    @IBOutlet weak var escalationAnalysis: UIView!
    @IBOutlet weak var categoryAnalysis: UIView!

    @IBOutlet weak var savePDF: UIImageView!

    // MARK: - Assets
    private let logo = UIImage(named: "Light mode logo, compressed & cropped")

    // MARK: - PDF constants (A4)
    private let pageBounds = CGRect(x: 0, y: 0, width: 595, height: 842) // A4
    private let leftPadding: CGFloat = 20
    private let rightPadding: CGFloat = 20
    private let headerHeight: CGFloat = 80
    private let footerSpace: CGFloat = 40
    private let startY: CGFloat = 90

    private var contentWidth: CGFloat {
        pageBounds.width - leftPadding - rightPadding
    }

    private var pageNumber: Int = 1

    // MARK: - Lifecycle
    override func viewDidLoad() {
        super.viewDidLoad()

        title = "Analytics"
        print("loaded", String(describing: type(of: self)))

        // show first segment by default
        analyticsSegment.selectedSegmentIndex = 0
        showSelectedAnalysis(animated: false)

        // make print image tappable
        savePDF.isUserInteractionEnabled = true
        let tapGesture = UITapGestureRecognizer(target: self, action: #selector(generatePDF))
        savePDF.addGestureRecognizer(tapGesture)
    }

    // MARK: - Segmented control
    @IBAction func segmentChanged(_ sender: UISegmentedControl) {
        showSelectedAnalysis(animated: true)
    }

    private func showSelectedAnalysis(animated: Bool) {

        let views = [requestAnalysis, timeAnalysis, escalationAnalysis, categoryAnalysis]
        let selectedIndex = analyticsSegment.selectedSegmentIndex

        for (index, view) in views.enumerated() {

            let shouldShow = (index == selectedIndex)

            if animated {
                if shouldShow {
                    view?.alpha = 0.0
                    view?.isHidden = false
                    UIView.animate(withDuration: 0.3) {
                        view?.alpha = 1.0
                    }
                } else {
                    UIView.animate(withDuration: 0.3, animations: {
                        view?.alpha = 0.0
                    }, completion: { _ in
                        view?.isHidden = true
                    })
                }
            } else {
                view?.isHidden = !shouldShow
                view?.alpha = shouldShow ? 1.0 : 0.0
            }
        }
    }

    // MARK: - PDF flow
    @objc private func generatePDF() {

        showConfirmationAlert(
            title: "Save PDF",
            message: "Do you want to save the analytics as a PDF?"
        ) { [weak self] in

            guard let self = self else { return }

            // ensure layout updated
            self.view.layoutIfNeeded()

            // update all containers (even if hidden)
            let containers = [self.requestAnalysis, self.timeAnalysis, self.escalationAnalysis, self.categoryAnalysis]
            for c in containers {
                c?.setNeedsLayout()
                c?.layoutIfNeeded()
                if let root = c { self.reloadNestedLists(in: root) }
            }

            RunLoop.current.run(until: Date().addingTimeInterval(0.05))

            self.createAndSavePDF()
        }
    }

    private func createAndSavePDF() {

        let fileName = "Performance_Analysis_Report.pdf"

        // saved inside app sandbox (Documents)
        let fileURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
            .appendingPathComponent(fileName)

        let renderer = UIGraphicsPDFRenderer(bounds: pageBounds)

        do {
            try renderer.writePDF(to: fileURL) { context in

                self.pageNumber = 1

                // each container becomes its own "section" (but can span many pages)
                let analysisViews: [UIView?] = [
                    self.requestAnalysis,
                    self.timeAnalysis,
                    self.escalationAnalysis,
                    self.categoryAnalysis
                ]

                for view in analysisViews {

                    guard let container = view else { continue }

                    // ensure visible for render, then restore
                    let wasHidden = container.isHidden
                    let oldAlpha = container.alpha

                    container.isHidden = false
                    container.alpha = 1.0
                    container.setNeedsLayout()
                    container.layoutIfNeeded()

                    // draw this container as multi-page
                    self.drawContainerAsPagedPDF(container, pdfContext: context)

                    container.isHidden = wasHidden
                    container.alpha = oldAlpha
                }
            }

            print("PDF URL:", fileURL)
            print("PDF Exists:", FileManager.default.fileExists(atPath: fileURL.path))

            // share sheet (use Save to Files to see it in Files app)
            let vc = UIActivityViewController(activityItems: [fileURL], applicationActivities: nil)
            vc.popoverPresentationController?.sourceView = self.view
            present(vc, animated: true)

        } catch {
            showAlert(title: "Error", message: "Failed to generate the PDF.")
        }
    }

    // MARK: - Draw one container as multi-page PDF (full width + full scroll content)
    private func drawContainerAsPagedPDF(_ containerView: UIView, pdfContext: UIGraphicsPDFRendererContext) {

        // 1) ensure all nested lists/scrolls have correct content sizes
        containerView.setNeedsLayout()
        containerView.layoutIfNeeded()
        reloadNestedLists(in: containerView)

        // 2) expand ALL nested scroll views to their full content height
        let scrolls = findAllScrollContainers(in: containerView)
        var savedStates: [(scroll: UIScrollView, frame: CGRect, offset: CGPoint)] = []

        for s in scrolls {
            savedStates.append((s, s.frame, s.contentOffset))

            // reset scroll to top
            s.contentOffset = .zero

            // make sure contentSize is updated
            reloadNestedLists(in: s)
            s.layoutIfNeeded()

            // expand to full height
            let fullHeight = max(s.contentSize.height, s.bounds.height)
            s.frame = CGRect(x: s.frame.origin.x, y: s.frame.origin.y, width: s.frame.width, height: fullHeight)
            s.layoutIfNeeded()
        }

        // 3) force container to PDF width, and compute fitted height
        let originalContainerFrame = containerView.frame

        let fittedHeight = containerView.systemLayoutSizeFitting(
            CGSize(width: contentWidth, height: UIView.layoutFittingCompressedSize.height),
            withHorizontalFittingPriority: .required,
            verticalFittingPriority: .fittingSizeLevel
        ).height

        containerView.frame = CGRect(x: 0, y: 0, width: contentWidth, height: fittedHeight)
        containerView.layoutIfNeeded()

        // 4) render the FULL container as ONE tall image (includes labels + charts + expanded scroll content)
        let imgRenderer = UIGraphicsImageRenderer(size: CGSize(width: contentWidth, height: fittedHeight))
        let fullImage = imgRenderer.image { _ in
            containerView.drawHierarchy(
                in: CGRect(x: 0, y: 0, width: contentWidth, height: fittedHeight),
                afterScreenUpdates: true
            )
        }

        // 5) restore scroll states and container frame
        for item in savedStates {
            item.scroll.frame = item.frame
            item.scroll.contentOffset = item.offset
            item.scroll.layoutIfNeeded()
        }

        containerView.frame = originalContainerFrame
        containerView.layoutIfNeeded()

        // 6) slice the tall image into multiple A4 pages (keeps scroll across pages)
        let usableHeight = pageBounds.height - startY - footerSpace
        var offsetY: CGFloat = 0

        while offsetY < fullImage.size.height {

            pdfContext.beginPage()

            // header/footer for each page
            drawPDFHeader()
            drawPDFFooter()

            let sliceHeight = min(usableHeight, fullImage.size.height - offsetY)

            // crop from the big image
            let sourceRect = CGRect(x: 0, y: offsetY, width: fullImage.size.width, height: sliceHeight)

            // draw into page (full width)
            let targetRect = CGRect(x: leftPadding, y: startY, width: contentWidth, height: sliceHeight)

            if let cg = fullImage.cgImage?.cropping(to: sourceRect) {
                UIImage(cgImage: cg).draw(in: targetRect)
            }

            offsetY += sliceHeight
            pageNumber += 1
        }
    }

    // MARK: - Header (NO segmented title)
    private func drawPDFHeader() {

        // logo
        let logoRect = CGRect(x: 20, y: 20, width: 40, height: 40)
        logo?.draw(in: logoRect)

        // title (fixed - no segment title)
        let titleText = "Performance Analysis Report"
        let attrs: [NSAttributedString.Key: Any] = [
            .font: UIFont.boldSystemFont(ofSize: 18)
        ]
        titleText.draw(at: CGPoint(x: 70, y: 30), withAttributes: attrs)

        // divider line
        let path = UIBezierPath()
        path.move(to: CGPoint(x: 20, y: 70))
        path.addLine(to: CGPoint(x: pageBounds.width - 20, y: 70))
        path.lineWidth = 1
        path.stroke()
    }

    // MARK: - Footer (with page number)
    private func drawPDFFooter() {

        let formatter = DateFormatter()
        formatter.dateStyle = .medium

        let footerText = "Generated on \(formatter.string(from: Date()))  •  Page \(pageNumber)"
        let attributes: [NSAttributedString.Key: Any] = [
            .font: UIFont.systemFont(ofSize: 10),
            .foregroundColor: UIColor.gray
        ]

        footerText.draw(
            at: CGPoint(x: leftPadding, y: pageBounds.height - footerSpace + 10),
            withAttributes: attributes
        )
    }

    // MARK: - Helpers: find all scroll views
    private func findAllScrollContainers(in root: UIView) -> [UIScrollView] {

        var result: [UIScrollView] = []

        func walk(_ v: UIView) {
            if let s = v as? UIScrollView {
                result.append(s)
            }
            for sub in v.subviews {
                walk(sub)
            }
        }

        walk(root)
        return result
    }

    // MARK: - Helpers: reload nested lists (table/collection)
    private func reloadNestedLists(in root: UIView) {

        if let c = root as? UICollectionView {
            c.reloadData()
            c.layoutIfNeeded()
        }

        if let t = root as? UITableView {
            t.reloadData()
            t.layoutIfNeeded()
        }

        for sub in root.subviews {
            reloadNestedLists(in: sub)
        }
    }

    // MARK: - Alerts
    private func showConfirmationAlert(title: String, message: String, confirmHandler: @escaping () -> Void) {

        let alert = UIAlertController(title: title, message: message, preferredStyle: .alert)

        alert.addAction(UIAlertAction(title: "Yes", style: .default, handler: { _ in
            confirmHandler()
        }))

        alert.addAction(UIAlertAction(title: "No", style: .cancel, handler: nil))

        present(alert, animated: true)
    }

    private func showAlert(title: String, message: String) {

        let alert = UIAlertController(title: title, message: message, preferredStyle: .alert)
        alert.addAction(UIAlertAction(title: "OK", style: .default))
        present(alert, animated: true)
    }
}        // show first segment by default
        analyticsSegment.selectedSegmentIndex = 0
        showSelectedAnalysis(animated: false)

        // make PDF icon tappable
        savePDF.isUserInteractionEnabled = true
        let tapGesture = UITapGestureRecognizer(target: self, action: #selector(generatePDF))
        savePDF.addGestureRecognizer(tapGesture)
    }

    // segment change
    @IBAction func segmentChanged(_ sender: UISegmentedControl) {
        showSelectedAnalysis(animated: true)
    }

    // show selected analysis
    private func showSelectedAnalysis(animated: Bool) {

        let views = [requestAnalysis, timeAnalysis, escalationAnalysis, categoryAnalysis]
        let selectedIndex = analyticsSegment.selectedSegmentIndex

        for (index, view) in views.enumerated() {

            let shouldShow = (index == selectedIndex)

            if animated {

                if shouldShow {
                    view?.alpha = 0.0
                    view?.isHidden = false
                    UIView.animate(withDuration: 0.3) {
                        view?.alpha = 1.0
                    }
                } else {
                    UIView.animate(withDuration: 0.3, animations: {
                        view?.alpha = 0.0
                    }, completion: { _ in
                        view?.isHidden = true
                    })
                }

            } else {
                view?.isHidden = !shouldShow
                view?.alpha = shouldShow ? 1.0 : 0.0
            }
        }
    }

    // generate PDF
    @objc private func generatePDF() {

        showConfirmationAlert(title: "Save PDF",
                              message: "Do you want to save the analytics as a PDF?") { [weak self] in
            guard let self = self else { return }

            // make sure layout is updated
            self.view.layoutIfNeeded()

            // force layout + reload nested lists (charts/collection/table)
            let containers = [self.requestAnalysis, self.timeAnalysis, self.escalationAnalysis, self.categoryAnalysis]
            for c in containers {
                c?.setNeedsLayout()
                c?.layoutIfNeeded()
                if let root = c { self.reloadNestedLists(in: root) }
            }

            // small delay to let charts finish drawing
            RunLoop.current.run(until: Date().addingTimeInterval(0.05))

            self.createAndSavePDF()
        }
    }

    private func createAndSavePDF() {

        let fileName = "Performance_Analysis_Report.pdf"

        let fileURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
            .appendingPathComponent(fileName)

        let renderer = UIGraphicsPDFRenderer(bounds: pageBounds)

        do {
            try renderer.writePDF(to: fileURL) { context in

                let analysisViews = [self.requestAnalysis, self.timeAnalysis, self.escalationAnalysis, self.categoryAnalysis]

                for (idx, viewOpt) in analysisViews.enumerated() {
                    guard let container = viewOpt else { continue }

                    // save visibility
                    let wasHidden = container.isHidden
                    let oldAlpha = container.alpha

                    // show for rendering
                    container.isHidden = false
                    container.alpha = 1.0
                    container.layoutIfNeeded()

                    // start first page for this section
                    context.beginPage()
                    self.drawPDFHeader(sectionIndex: idx)
                    self.drawPDFFooter(pageIndexText: "Page 1")

                    // draw content (auto handles scroll & multi-pages)
                    self.drawContainerIncludingScroll(container, pdfContext: context)

                    // restore
                    container.isHidden = wasHidden
                    container.alpha = oldAlpha
                }
            }

            // share (Save to Files to appear in Files app)
            let vc = UIActivityViewController(activityItems: [fileURL], applicationActivities: nil)
            vc.popoverPresentationController?.sourceView = self.view
            present(vc, animated: true)

            print("PDF URL:", fileURL)
            print("PDF Exists:", FileManager.default.fileExists(atPath: fileURL.path))

        } catch {
            showAlert(title: "Error", message: "Failed to generate the PDF.")
        }
    }

    // MARK: - Header / Footer

    private func drawPDFHeader(sectionIndex: Int) {

        // logo
        let logoRect = CGRect(x: 20, y: 20, width: 40, height: 40)
        logo?.draw(in: logoRect)

        // title
        let title = "Performance Analysis Report"
        let attributes: [NSAttributedString.Key: Any] = [
            .font: UIFont.boldSystemFont(ofSize: 18)
        ]
        title.draw(at: CGPoint(x: 70, y: 30), withAttributes: attributes)

        // optional section label
        let sectionTitles = ["Requests", "Time", "Escalations", "Categories"]
        let section = sectionIndex < sectionTitles.count ? sectionTitles[sectionIndex] : "Analytics"
        let secAttr: [NSAttributedString.Key: Any] = [
            .font: UIFont.systemFont(ofSize: 12),
            .foregroundColor: UIColor.gray
        ]
        section.draw(at: CGPoint(x: 70, y: 52), withAttributes: secAttr)

        // divider
        let path = UIBezierPath()
        path.move(to: CGPoint(x: 20, y: 70))
        path.addLine(to: CGPoint(x: 575, y: 70))
        path.lineWidth = 1
        path.stroke()
    }

    private func drawPDFFooter(pageIndexText: String) {

        let formatter = DateFormatter()
        formatter.dateStyle = .medium

        let footerText = "Generated on \(formatter.string(from: Date()))   •   \(pageIndexText)"
        let attributes: [NSAttributedString.Key: Any] = [
            .font: UIFont.systemFont(ofSize: 10),
            .foregroundColor: UIColor.gray
        ]

        footerText.draw(at: CGPoint(x: 20, y: pageBounds.height - 22), withAttributes: attributes)
    }

    // MARK: - Core: draw container + FULL scroll content across pages

    private func drawContainerIncludingScroll(_ containerView: UIView, pdfContext context: UIGraphicsPDFRendererContext) {

        // find first scroll inside container (you said you have only one)
        if let scrollView = findFirstScrollContainer(in: containerView) {
            drawScrollViewFullContent(scrollView, pdfContext: context)
        } else {
            drawNormalView(containerView)
        }
    }

    // draw a normal view (not scrollable) on one page
    private func drawNormalView(_ view: UIView) {

        guard let ctx = UIGraphicsGetCurrentContext() else { return }

        let maxDrawableHeight = pageBounds.height - startY - footerSpace

        // fit height based on autolayout
        let targetSize = CGSize(width: contentWidth, height: UIView.layoutFittingCompressedSize.height)
        let fittedHeight = view.systemLayoutSizeFitting(
            targetSize,
            withHorizontalFittingPriority: .required,
            verticalFittingPriority: .fittingSizeLevel
        ).height

        let scale = min(1.0, maxDrawableHeight / max(fittedHeight, 1))

        ctx.saveGState()
        ctx.translateBy(x: leftPadding, y: startY)
        ctx.scaleBy(x: scale, y: scale)
        view.layer.render(in: ctx)
        ctx.restoreGState()
    }

    // ✅ draw FULL scroll content and split into multiple A4 pages
    private func drawScrollViewFullContent(_ scrollView: UIScrollView, pdfContext context: UIGraphicsPDFRendererContext) {

        guard let ctx = UIGraphicsGetCurrentContext() else { return }

        // make sure contentSize is correct (collection/table/charts)
        reloadNestedLists(in: scrollView)
        scrollView.layoutIfNeeded()

        let originalOffset = scrollView.contentOffset
        let originalFrame = scrollView.frame

        scrollView.contentOffset = .zero
        scrollView.layoutIfNeeded()

        // full content size
        let contentSize = scrollView.contentSize
        let contentHeight = max(contentSize.height, scrollView.bounds.height)

        // how much height we can draw per page
        let drawableHeight = pageBounds.height - startY - footerSpace
        let pageSliceHeight = drawableHeight

        // scale to fit width
        let scale = contentWidth / max(contentSize.width, 1)

        // how many pages needed
        let totalScaledHeight = contentHeight * scale
        let pages = Int(ceil(totalScaledHeight / pageSliceHeight))

        for pageIndex in 0..<pages {

            if pageIndex > 0 {
                context.beginPage()
                drawPDFHeader(sectionIndex: 0) // header again (simple)
                drawPDFFooter(pageIndexText: "Page \(pageIndex + 1)")
            }

            // clip to page area
            ctx.saveGState()
            ctx.translateBy(x: leftPadding, y: startY)

            // define visible slice rect in PDF coordinates
            let clipRect = CGRect(x: 0, y: 0, width: contentWidth, height: drawableHeight)
            ctx.clip(to: clipRect)

            // move content up for each page slice
            // (negative Y to show lower parts)
            let yOffset = CGFloat(pageIndex) * pageSliceHeight
            ctx.translateBy(x: 0, y: -yOffset)

            // scale to fit width
            ctx.scaleBy(x: scale, y: scale)

            // render full scroll content
            // IMPORTANT: expand frame height so layer renders full content
            scrollView.frame = CGRect(x: 0, y: 0, width: scrollView.frame.width, height: contentHeight)
            scrollView.layer.render(in: ctx)

            ctx.restoreGState()
        }

        // restore original state
        scrollView.contentOffset = originalOffset
        scrollView.frame = originalFrame
        scrollView.layoutIfNeeded()
    }

    // find first scroll inside a view
    private func findFirstScrollContainer(in root: UIView) -> UIScrollView? {

        if let scroll = root as? UIScrollView { return scroll }

        for sub in root.subviews {
            if let found = findFirstScrollContainer(in: sub) {
                return found
            }
        }
        return nil
    }

    // reload collection/table inside any view
    private func reloadNestedLists(in root: UIView) {

        if let c = root as? UICollectionView {
            c.reloadData()
            c.layoutIfNeeded()
        }

        if let t = root as? UITableView {
            t.reloadData()
            t.layoutIfNeeded()
        }

        for sub in root.subviews {
            reloadNestedLists(in: sub)
        }
    }

    // MARK: - Alerts

    private func showConfirmationAlert(title: String, message: String, confirmHandler: @escaping () -> Void) {

        let alert = UIAlertController(title: title, message: message, preferredStyle: .alert)

        alert.addAction(UIAlertAction(title: "Yes", style: .default, handler: { _ in
            confirmHandler()
        }))

        alert.addAction(UIAlertAction(title: "No", style: .cancel))

        present(alert, animated: true)
    }

    private func showAlert(title: String, message: String) {

        let alert = UIAlertController(title: title, message: message, preferredStyle: .alert)
        alert.addAction(UIAlertAction(title: "OK", style: .default))

        present(alert, animated: true)
    }
}
